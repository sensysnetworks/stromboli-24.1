/* SCILAB Computational function  */
/*     Copyright INRIA */
/*     Generated by Code_Generation toolbox of Scicos with scilab-2.6 */
/*     date : 2-Dec-2002 */

#include <stdio.h>
#include <string.h>
#include "/home/mante/scilab-2.6/routines/machine.h"
#include "/home/mante/scilab-2.6/routines/sun/link.h"
#include "/home/mante/scilab-2.6/routines/scicos/scicos.h"
 
void Controllermain1(double *z, double *t, double * rpar, int *nrpar,
   int *ipar, int *nipar);
 
void Controllermain2(double *z, double *t, double * rpar, int *nrpar,
   int *ipar, int *nipar) ;
 
void Controller_init(double *z, double *t, double * rpar, int *nrpar,
   int *ipar, int *nipar) ;
 
void Controller_end(double *z, double *t, double * rpar, int *nrpar,
   int *ipar, int *nipar) ;
 
int Controller()  ;
 
int Controllerddoit1(double *z, int * zptr, double *t, double *tevts,
   int *evtspt, int * nevts, int *pointi, int * outptr, int *clkptr,
   int *ordptr, int *ordclk, int *nordcl, double * rpar, int *ipar,
   int *funptr, int *funtyp, double *outtb, int *iwa)  ;
 
int Controllerddoit2(double *z, int * zptr, double *t, double *tevts,
   int *evtspt, int * nevts, int *pointi, int * outptr, int *clkptr,
   int *ordptr, int *ordclk, int *nordcl, double * rpar, int *ipar,
   int *funptr, int *funtyp, double *outtb, int *iwa)  ;
 
int Controlleredoit1(double *z, int * zptr, double *t, double *tevts,
   int *evtspt, int * nevts, int *pointi, int * outptr, int *clkptr,
   int *ordptr, int *ordclk, int *nordcl, double * rpar, int *ipar,
   int *funptr, int *funtyp, double *outtb, int * urg, int *iwa)  ;
 
int Controller_initi(double *z, int * zptr, double *t, double *tevts,
   int *evtspt, int * nevts, int *pointi, int * outptr, int *clkptr,
   int *ordptr, int *ordclk, int *nordcl, double * rpar, int *ipar,
   int *funptr, int *funtyp, double *outtb, int *iwa)  ;
 
int Controller_endi(double *z, int * zptr, double *t, double *tevts,
   int *evtspt, int * nevts, int *pointi, int * outptr, int *clkptr,
   int *ordptr, int *ordclk, int *nordcl, double * rpar, int *ipar,
   int *funptr, int *funtyp, double *outtb, int *iwa)  ;
 
int Controller_outtb(double *z, int * zptr, double *t, double *tevts,
   int *evtspt, int * nevts, int *pointi, int * outptr, int *clkptr,
   int *ordptr, int *ordclk, int *nordcl, double * rpar, int *ipar,
   int *funptr, int *funtyp, double *outtb, int *iwa)  ;
 
int C2F(putevs)(double *tevts, int *evtspt, int * nevts, int *pointi,
   double *told, int *i2, int *ierr);
/* ---- block simulation functions -------*/
 

void C2F(dsslti)(int *flag, int *nevprt, double *told, double *xd,
   double *x, int *nx, double *z, int *nz, double *tvec, int *ntvec,
   double *rpar, int *nrpar,int *ipar,int *nipar, double *u, int *nu,
   double *y, int *ny);

void Controller_actuator(int *flag, int *nport, int *nevprt,
   double *t, double *u, int *nu);

void Controller_sensor(int *flag, int *nport, int *nevprt, double *t,
   double *y, int *ny);

void C2F(bidon)(int *flag, int *nevprt, double *told, double *xd,
   double *x, int *nx, double *z, int *nz, double *tvec, int *ntvec,
   double *rpar, int *nrpar,int *ipar,int *nipar, double *u, int *nu,
   double *y, int *ny);

void C2F(gain)(int *flag, int *nevprt, double *told, double *xd,
   double *x, int *nx, double *z, int *nz, double *tvec, int *ntvec,
   double *rpar, int *nrpar,int *ipar,int *nipar, double *u, int *nu,
   double *y, int *ny);

void C2F(samphold)(int *flag, int *nevprt, double *told, double *xd,
   double *x, int *nx, double *z, int *nz, double *tvec, int *ntvec,
   double *rpar, int *nrpar,int *ipar,int *nipar, double *u, int *nu,
   double *y, int *ny);

void plusblk(int *flag, int *nevprt,double *told, double *xd,
   double *x, int *nx, double *z, int *nz, double *tvec,  int *ntvec,
   double *rpar, int *nrpar, int *ipar, int *nipar,  double **inptr,
   int* insz, int *nin, double **outptr,int *outsz, int *nout);
/* Table of constant values */ 
 
static integer totalnevprt; 
static integer evtspt[ ]={-1};
static integer nevts[ ]={1};
static double x[1];
static integer zptr[ ]={1,2,2,2,2,3,3,3,3,3,3,3};
static integer clkptr[ ]={1,1,1,1,2,2,2,2,2,2,2,2};
static integer ordptr[ ]={1,11};
static integer ordclk[ ]={1,2,3,5,10,11,6,9,8,7,1,1,1,1,1,1,1,1,3,1};
static integer outptr[ ]={1,2,2,3,3,4,5,6,7,8,9,9};
static double tevts[ ] = {0};
static integer rdfunptr[ ]={1,2,3,4,5,6,7,8,9,10,11};
static integer funtyp[ ]={0,0,0,0,0,0,0,2,0,0,0};
static double w[1];
void set_nevprt(int nevprt)
{
  totalnevprt=nevprt;
}
/*---------------------------------------- Block Computational function */ 
int 
Controller(flag ,nevprt ,t ,xd ,x ,nx ,z ,nz ,tvec ,ntvec ,rpar ,
  nrpar ,ipar ,nipar ,u1 ,nu1 ,u2 ,nu2 ,y1 ,ny1 ,y2 ,ny2)

  integer *flag ,*nevprt ,*nx ,*nz ,*ntvec ,*nrpar ,*ipar ,*nipar ,
    *nu1 ,*nu2 ,*ny1 ,*ny2;
  double  *t ,*xd ,*x ,*z ,*tvec ,*rpar ,*u1 ,*u2 ,*y1 ,*y2;

{
  /*  block_outtb is catenated at the end of z*/
  double* block_outtb = z+2;

  /*Copy inputs in the block outtb */
  block_outtb[5] = u1[0];
  block_outtb[4] = u2[0];
   set_nevprt(*nevprt);
 
  if (*flag == 1) { /* update outputs */
    Controllermain1(z,t,rpar,nrpar,ipar,nipar);
  } 
  else if (*flag == 2) { /* update discrete states */
    Controllermain2(z,t,rpar,nrpar,ipar,nipar);
  } 
  else if (*flag == 4) { /* initialisation */
    Controller_init(z,t,rpar,nrpar,ipar,nipar);
  } 
  else if (*flag == 5) { /* ending */
    Controller_end(z,t,rpar,nrpar,ipar,nipar);
  } 
  y1[0] =  block_outtb[0];
  y2[0] =  block_outtb[7];
  return 0;

} /* Controller */
/*---------------------------------------- main1 */ 
void 
Controllermain1(double *z, double *t, double * rpar, integer *nrpar,
  integer *ipar,integer *nipar)
{
  integer pointi[ ]={0};
integer nordcl = 10;

  Controllerddoit1(z, zptr, t, tevts, evtspt, nevts, pointi, outptr,
     clkptr, ordptr, ordclk, &nordcl, rpar, ipar, rdfunptr, funtyp,
     &(z[2]), (int *)(z+10));
} 
/*---------------------------------------- main2 */ 
void 
Controllermain2(double *z, double *t, double * rpar, integer *nrpar,
  integer *ipar,integer *nipar)
{
  integer pointi[ ]={0};
integer nordcl = 10;

  Controllerddoit2(z, zptr, t, tevts, evtspt, nevts, pointi, outptr,
     clkptr, ordptr, ordclk, &nordcl, rpar, ipar, rdfunptr, funtyp,
     &(z[2]), (int *)(z+10));
} 
/*---------------------------------------- init */ 
void 
Controller_init(double *z, double *t, double * rpar, integer *nrpar,
  integer *ipar,integer *nipar)
{
  integer pointi[ ]={0};
integer nordcl = 10;
  /*Block initializations*/
  Controller_initi(z, zptr, t, tevts, evtspt, nevts, pointi, outptr,
     clkptr, ordptr, ordclk, &nordcl, rpar, ipar, rdfunptr,funtyp,
     &(z[2]), (int *)(z+10));
  /*Constants propagation*/
  Controller_outtb(z, zptr, t, tevts, evtspt, nevts, pointi, outptr,
     clkptr, ordptr, ordclk, &nordcl, rpar, ipar, rdfunptr,funtyp,
     &(z[2]), (int *)(z+10));
} 
/*---------------------------------------- end */ 
void 
Controller_end(double *z, double *t, double * rpar, integer *nrpar,
  integer *ipar,integer *nipar)
{
  integer pointi[ ]={0};
integer nordcl = 10;

  Controller_endi(z, zptr, t, tevts, evtspt, nevts, pointi, outptr,
     clkptr, ordptr, ordclk, &nordcl, rpar, ipar, rdfunptr, funtyp,
     &(z[2]), (int *)(z+10));
} 

/*---------------------------------------- ddoit1.c */ 
int 
Controllerddoit1( z, zptr, told, tevts, evtspt, nevts, pointi, outptr,
   clkptr, ordptr, ordclk, nordcl, rpar, ipar, funptr, funtyp, outtb,
   iwa)

     double  *z; 
     integer *zptr; 
     double  *told,  *tevts; 

     integer *evtspt, *nevts, *pointi, *outptr; 
     integer *clkptr, *ordptr, *ordclk, *nordcl; 
     double  *rpar, *outtb; 
     integer *ipar, *funptr, *funtyp; 
     integer *iwa; 
{
  /* System generated locals */ 
  integer ordclk_dim1, ordclk_offset, i2; 
 
  /* Local variables */ 
  integer flag, keve, nport; 
  double  tvec[2]; 
  double  rdouttb[9]; 
  double  *args[100]; 
  integer sz[100]; 
  integer ierr1; 
  integer ntvec; 
  integer nevprt; 
  integer urg; 
 
  /* Generated constants */
  integer nrd_0 = 0;
  integer nrd_1 = 1;
  integer nrd_2 = 2;
  integer nrd_3 = 3;
  integer nrd_4 = 4;
  /* Parameter adjustments */ 
  --z; 
  --zptr; 
  --tevts; 
  --evtspt; 
  --outptr; 
  --clkptr; 
  --ordptr; 

  ordclk_dim1 = *nordcl; 
  ordclk_offset = ordclk_dim1 + 1; 
  ordclk -= ordclk_offset; 
  --rpar; 
  --ipar; 
  --funptr; 
  --funtyp; 
  --iwa; 
  --outtb; 
 
  /* Function Body */ 
  iwa[11] = 0; 
  urg = 0; 
  *pointi=0+ totalnevprt;
  tevts[*pointi]=*told;
  keve = *pointi; 
  *pointi = evtspt[keve]; 
  evtspt[keve] = -1; 
 
  ++iwa[11]; 
  iwa[iwa[11]] = keve;
 
  switch(keve) {
  case 1:
 
    flag = 1; 
    nevprt=1;
   args[0]=&(outtb[7]);
   args[1]=&(outtb[1]);
   C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_1, tvec, &ntvec, &(rpar[1]), &nrd_4, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
    if(flag < 0 ) return(5 - flag);
 
    flag = 1; 
    nevprt=1;
   args[1]=&(outtb[6]);
   nport = 1;
   Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);
    if(flag < 0 ) return(5 - flag);
 
    flag = 1; 
    nevprt=1;
   args[0]=&(outtb[2]);
   args[1]=&(outtb[7]);
   C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[2]),
      &nrd_1, tvec, &ntvec, &(rpar[5]), &nrd_4, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
    if(flag < 0 ) return(5 - flag);
 
    flag = 1; 
    nevprt=1;
   args[1]=&(outtb[5]);
   nport = 2;
   Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);
    if(flag < 0 ) return(5 - flag);
 
    flag = 1; 
    nevprt=1;
   args[0]=&(outtb[6]);
   args[1]=&(outtb[3]);
   C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[9]), &nrd_1, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
    if(flag < 0 ) return(5 - flag);
 
    flag = 1; 
    nevprt=1;
   args[0]=&(outtb[5]);
   args[1]=&(outtb[4]);
   C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[10]), &nrd_1, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
    if(flag < 0 ) return(5 - flag);
 
    flag = 1; 
    nevprt=3;
   args[0] = &(outtb[3]);
   sz[0] = 1;
   args[1] = &(outtb[4]);
   sz[1] = 1;
   args[2] = &(outtb[8]);
   sz[2] = 1;
   plusblk(&flag, &nevprt, told,&(w[1]), &(x[1]), &nrd_0, &(z[1]),&nrd_0,
      tvec, &ntvec, &(rpar[1]), &nrd_0,&(ipar[1]), &nrd_0, &(args[0]),
      &(sz[0]), &nrd_2,&(args[2]),&(sz[2]),&nrd_1);
    
    if(flag < 0 ) return(5 - flag);
 
    flag = 1; 
    nevprt=1;
   args[0]=&(outtb[8]);
   args[1]=&(outtb[2]);
   C2F(samphold)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[1]), &nrd_0, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
    if(flag < 0 ) return(5 - flag);
    break;
  }  
  
  switch(keve) {
  case 1:
    break;
  }
  if (urg > 0) {
 L43:
    Controlleredoit1(&z[1], &zptr[1], told, &tevts[1], &evtspt[1], nevts,
       pointi, &outptr[1], &clkptr[1], &ordptr[1],  &ordclk[ordclk_offset],
       nordcl, &rpar[1], &ipar[1], &funptr[1], &funtyp[1], &(z[3]), &urg,
       (int *)(z+11));
    if (urg > 0) {
      goto L43;
    }
  }
  return 0;
 
} /* ddoit1 */
  
/*---------------------------------------- edoit1.c */ 
int 
Controlleredoit1( z, zptr, told,tevts, evtspt, nevts, pointi,  outptr,
   clkptr, ordptr, ordclk, nordcl, rpar, ipar, funptr, funtyp, outtb,
   urg, iwa)
     double  *z; 
     integer *zptr; 
     double  *told,  *tevts; 
     integer *evtspt, *nevts, *pointi, *outptr; 
     integer *clkptr, *ordptr, *ordclk, *nordcl; 
     double  *rpar, *outtb; 
     integer *ipar,  *funptr, *funtyp; 
     integer *urg,  *iwa; 
{ 
  /* System generated locals */ 
  integer ordclk_dim1, ordclk_offset, i2; 
 
  /* Local variables */ 
  integer flag, keve, nport; 
  integer nord; 
  double  tvec[2]; 
  double  rdouttb[9]; 
  double  *args[100]; 
  integer sz[100]; 
  integer ierr1, i, nx=0; 
  integer ntvec, nevprt; 
 
  /* Generated constants */
  integer nrd_0 = 0;
  integer nrd_1 = 1;
  integer nrd_2 = 2;
  integer nrd_3 = 3;
  integer nrd_4 = 4;
  /* Parameter adjustments */ 
  --z; 
  --zptr; 
  --tevts; 
  --evtspt; 
  --outptr; 
  --clkptr; 
  --ordptr; 
  ordclk_dim1 = *nordcl; 
  ordclk_offset = ordclk_dim1 + 1; 
  ordclk -= ordclk_offset; 
  --rpar; 
  --ipar; 
  --funptr; 
  --funtyp; 
  --iwa; 
  --outtb; 
 
  /* Function Body */ 
  --(*urg); 
  keve = *pointi; 
  *pointi = evtspt[keve]; 
  evtspt[keve] = -1; 
 
  nord = ordptr[keve + 1] - ordptr[keve]; 
  if (nord == 0) { 
    return 0; 
  } 
  ++(iwa[11]);   
  iwa[iwa[11]] = keve;   
  switch(keve) {
  case 1:
    flag = 1 ;
    nevprt=1;
   args[0]=&(outtb[7]);
   args[1]=&(outtb[1]);
   C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_1, tvec, &ntvec, &(rpar[1]), &nrd_4, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
 
    if(flag < 0 ) return(5 - flag);
 
    flag = 1 ;
    nevprt=1;
   args[1]=&(outtb[6]);
   nport = 1;
   Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);
 
    if(flag < 0 ) return(5 - flag);
 
    flag = 1 ;
    nevprt=1;
   args[0]=&(outtb[2]);
   args[1]=&(outtb[7]);
   C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[2]),
      &nrd_1, tvec, &ntvec, &(rpar[5]), &nrd_4, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
 
    if(flag < 0 ) return(5 - flag);
 
    flag = 1 ;
    nevprt=1;
   args[1]=&(outtb[5]);
   nport = 2;
   Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);
 
    if(flag < 0 ) return(5 - flag);
 
    flag = 1 ;
    nevprt=1;
   args[0]=&(outtb[6]);
   args[1]=&(outtb[3]);
   C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[9]), &nrd_1, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
 
    if(flag < 0 ) return(5 - flag);
 
    flag = 1 ;
    nevprt=1;
   args[0]=&(outtb[5]);
   args[1]=&(outtb[4]);
   C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[10]), &nrd_1, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
 
    if(flag < 0 ) return(5 - flag);
 
    flag = 1 ;
    nevprt=3;
   args[0] = &(outtb[3]);
   sz[0] = 1;
   args[1] = &(outtb[4]);
   sz[1] = 1;
   args[2] = &(outtb[8]);
   sz[2] = 1;
   plusblk(&flag, &nevprt, told,&(w[1]), &(x[1]), &nrd_0, &(z[1]),&nrd_0,
      tvec, &ntvec, &(rpar[1]), &nrd_0,&(ipar[1]), &nrd_0, &(args[0]),
      &(sz[0]), &nrd_2,&(args[2]),&(sz[2]),&nrd_1);
    
 
    if(flag < 0 ) return(5 - flag);
 
    flag = 1 ;
    nevprt=1;
   args[0]=&(outtb[8]);
   args[1]=&(outtb[2]);
   C2F(samphold)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[1]), &nrd_0, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
 
    if(flag < 0 ) return(5 - flag);
 
    break;
  }  
  
  switch(keve) {
  case 1:
    break;
  }  
  return 0;
} /* edoit1 */      

/*---------------------------------------- ddoit2 */ 
int 
Controllerddoit2( z, zptr, told, tevts, evtspt, nevts, pointi, outptr,
   clkptr, ordptr, ordclk, nordcl, rpar,  ipar, funptr, funtyp, outtb,
   iwa)

     double  *z; 
     integer *zptr; 
     double  *told,  *tevts; 
     integer *evtspt, *nevts, *pointi, *outptr; 
     integer *clkptr, *ordptr, *ordclk, *nordcl; 
     double  *rpar, *outtb; 
     integer *ipar, *funptr, *funtyp; 
     integer *iwa; 
{ 
  /* System generated locals */ 
  integer  i1, i; 
 
  /* Local variables */ 
  integer flag, keve, nport; 
  double  tvec[2]; 
  double  rdouttb[9]; 
  double  *args[100]; 
  integer sz[100]; 
  integer ntvec; 
  integer nevprt; 
 
  /* Generated constants */
  integer nrd_0 = 0;
  integer nrd_1 = 1;
  integer nrd_2 = 2;
  integer nrd_3 = 3;
  integer nrd_4 = 4;
    /* Parameter adjustments */ 
  --z; 
  --zptr; 
  --tevts; 
  --evtspt; 
  --outptr; 
  --clkptr; 
  --ordptr; 
  --rpar; 
  --ipar; 
  --funptr; 
  --funtyp; 
  --iwa; 
  --outtb; 
 
  /* Function Body */ 
 
  /*update continuous and discrete states on event */
  if (iwa[11] == 0) {
    return 0 ;
  }
  i1 = iwa[11];
  for (i = 1; i <= i1; ++i) {
    keve = iwa[i];
    switch(keve) {
    case 1:
    flag = 2;
    nevprt=1;
   args[0]=&(outtb[7]);
   args[1]=&(outtb[1]);
   C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_1, tvec, &ntvec, &(rpar[1]), &nrd_4, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=1;
   args[0]=&(outtb[1]);
   nport = 1;
   Controller_actuator(&flag, &nport, &nevprt, told, (double *)args[0], &nrd_1);
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=1;
   args[1]=&(outtb[6]);
   nport = 1;
   Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=1;
   args[0]=&(outtb[2]);
   args[1]=&(outtb[7]);
   C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[2]),
      &nrd_1, tvec, &ntvec, &(rpar[5]), &nrd_4, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=1;
   args[1]=&(outtb[5]);
   nport = 2;
   Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=1;
   args[0]=&(outtb[8]);
   nport = 2;
   Controller_actuator(&flag, &nport, &nevprt, told, (double *)args[0], &nrd_1);
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=1;
   args[0]=&(outtb[6]);
   args[1]=&(outtb[3]);
   C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[9]), &nrd_1, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=1;
   args[0]=&(outtb[5]);
   args[1]=&(outtb[4]);
   C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[10]), &nrd_1, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=3;
   args[0] = &(outtb[3]);
   sz[0] = 1;
   args[1] = &(outtb[4]);
   sz[1] = 1;
   args[2] = &(outtb[8]);
   sz[2] = 1;
   plusblk(&flag, &nevprt, told,&(w[1]), &(x[1]), &nrd_0, &(z[1]),&nrd_0,
      tvec, &ntvec, &(rpar[1]), &nrd_0,&(ipar[1]), &nrd_0, &(args[0]),
      &(sz[0]), &nrd_2,&(args[2]),&(sz[2]),&nrd_1);
    
	   if(flag < 0 ) return (5 - flag); 
    flag = 2;
    nevprt=1;
   args[0]=&(outtb[8]);
   args[1]=&(outtb[2]);
   C2F(samphold)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
      &nrd_0, tvec, &ntvec, &(rpar[1]), &nrd_0, &(ipar[1]), &nrd_0,
      (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
    
	   if(flag < 0 ) return (5 - flag); 
    break;
    }
  }
  return 0;
} /* ddoit2 */
/*---------------------------------------- outtbini */ 
int 
Controller_outtb( z, zptr, told, tevts, evtspt, nevts, pointi, outptr,
	clkptr, ordptr, ordclk, nordcl, rpar, ipar, funptr, funtyp, 
    outtb, iwa) 

     /*Constants propagation*/
     double  *z; 
     integer *zptr; 
     double  *told,  *tevts; 
     integer *evtspt, *nevts, *pointi, *outptr; 
     integer *clkptr, *ordptr, *ordclk, *nordcl; 
     double  *rpar, *outtb; 
     integer *ipar, *funptr, *funtyp; 
     integer *iwa; 
{ 
 
  /* Local variables */ 
  integer flag; 
  double  tvec[2]; 
  double  rdouttb[9]; 
  double  *args[100]; 
  integer sz[100]; 
  integer ntvec; 
  integer nevprt=0; 
 
  /* Generated constants */
  integer nrd_0 = 0;
  integer nrd_1 = 1;
  integer nrd_2 = 2;
  integer nrd_3 = 3;
  integer nrd_4 = 4;
  /* Parameter adjustments */ 
  --z; 
  --zptr; 
  --tevts; 
  --evtspt; 
  --outptr; 
  --clkptr; 
  --ordptr; 
  --rpar; 
  --ipar; 
  --funptr; 
  --funtyp; 
  --iwa; 
  --outtb; 
 
  /* Function Body */ 
  
  flag=1 ;
  args[0]=&(outtb[1]);
  args[1]=&(outtb[1]);
  C2F(bidon)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[1]), &nrd_0, &(ipar[3]), &nrd_1,
     (double *)args[0], &nrd_0, (double *)args[1], &nrd_0);
   
   if(flag < 0 ) return(5 - flag); 
  return 0;
} /* Controller_outtb */
/*---------------------------------------- initi */ 
int 
Controller_initi( z, zptr, told, tevts, evtspt, nevts, pointi, outptr,
	clkptr, ordptr, ordclk, nordcl, rpar, ipar, funptr, funtyp, 
    outtb, iwa) 

     /*Block initialization (flag=4)*/
     double  *z; 
     integer *zptr; 
     double  *told,  *tevts; 
     integer *evtspt, *nevts, *pointi, *outptr; 
     integer *clkptr, *ordptr, *ordclk, *nordcl; 
     double  *rpar, *outtb; 
     integer *ipar, *funptr, *funtyp; 
     integer *iwa; 
{ 
 
  /* Local variables */ 
  integer flag; 
  double  tvec[2]; 
  double  rdouttb[9]; 
  double  *args[100]; 
  integer sz[100]; 
  integer nport; 
  integer ntvec; 
  integer nevprt=0; 
 
  /* Generated constants */
  integer nrd_0 = 0;
  integer nrd_1 = 1;
  integer nrd_2 = 2;
  integer nrd_3 = 3;
  integer nrd_4 = 4;
  /* Parameter adjustments */ 
  --z; 
  --zptr; 
  --tevts; 
  --evtspt; 
  --outptr; 
  --clkptr; 
  --ordptr; 
  --rpar; 
  --ipar; 
  --funptr; 
  --funtyp; 
  --iwa; 
  --outtb; 
 
  /* Function Body */ 
  
  flag=4 ;
  args[0]=&(outtb[7]);
  args[1]=&(outtb[1]);
  C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_1, tvec, &ntvec, &(rpar[1]), &nrd_4, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   
   if(flag < 0 )  return(5 - flag);
  
  args[0]=&(outtb[1]);
  nport = 1;
  Controller_actuator(&flag, &nport, &nevprt, told, (double *)args[0], &nrd_1);
   if(flag < 0 )  return(5 - flag);
  
  args[1]=&(outtb[6]);
  nport = 1;
  Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);
   if(flag < 0 )  return(5 - flag);
  
  args[0]=&(outtb[1]);
  args[1]=&(outtb[1]);
  C2F(bidon)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[1]), &nrd_0, &(ipar[3]), &nrd_1,
     (double *)args[0], &nrd_0, (double *)args[1], &nrd_0);
   
   if(flag < 0 )  return(5 - flag);
  
  args[0]=&(outtb[2]);
  args[1]=&(outtb[7]);
  C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[2]),
     &nrd_1, tvec, &ntvec, &(rpar[5]), &nrd_4, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   
   if(flag < 0 )  return(5 - flag);
  
  args[0]=&(outtb[6]);
  args[1]=&(outtb[3]);
  C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[9]), &nrd_1, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   
   if(flag < 0 )  return(5 - flag);
  
  args[0]=&(outtb[8]);
  args[1]=&(outtb[2]);
  C2F(samphold)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[1]), &nrd_0, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   
   if(flag < 0 )  return(5 - flag);
  
  args[0] = &(outtb[3]);
  sz[0] = 1;
  args[1] = &(outtb[4]);
  sz[1] = 1;
  args[2] = &(outtb[8]);
  sz[2] = 1;
  plusblk(&flag, &nevprt, told,&(w[1]), &(x[1]), &nrd_0, &(z[1]),&nrd_0,
     tvec, &ntvec, &(rpar[1]), &nrd_0,&(ipar[1]), &nrd_0, &(args[0]),
     &(sz[0]), &nrd_2,&(args[2]),&(sz[2]),&nrd_1);
   
   if(flag < 0 )  return(5 - flag);
  
  args[0]=&(outtb[5]);
  args[1]=&(outtb[4]);
  C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[10]), &nrd_1, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   
   if(flag < 0 )  return(5 - flag);
  
  args[1]=&(outtb[5]);
  nport = 2;
  Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);
   if(flag < 0 )  return(5 - flag);
  
  args[0]=&(outtb[8]);
  nport = 2;
  Controller_actuator(&flag, &nport, &nevprt, told, (double *)args[0], &nrd_1);
   if(flag < 0 )  return(5 - flag);
  
  return 0;
} /* Controller_initi */
/*---------------------------------------- endi */ 
/* file_end.c */ 
/* Subroutine */ int 
Controller_endi( z, zptr, told, 
    tevts, evtspt, nevts, pointi, outptr, 
    clkptr, ordptr, ordclk, nordcl,  
    rpar, ipar, funptr, funtyp, outtb, iwa) 

     double  *z; 
     integer *zptr; 
     double  *told,  *tevts; 
     integer *evtspt, *nevts, *pointi, *outptr; 
     integer *clkptr, *ordptr, *ordclk, *nordcl; 
     double  *rpar, *outtb; 
     integer *ipar, *funptr, *funtyp; 
     integer *iwa; 
{ 
  /* Local variables */ 
  integer flag; 
  double  tvec[2]; 
  double  rdouttb[9]; 
  double  *args[100]; 
  integer sz[100]; 
  integer nport; 
  integer ntvec; 
  integer nevprt; 
 
  /* Generated constants */
  integer nrd_0 = 0;
  integer nrd_1 = 1;
  integer nrd_2 = 2;
  integer nrd_3 = 3;
  integer nrd_4 = 4;
  /* Parameter adjustments */ 
  --z; 
  --zptr; 
  --tevts; 
  --evtspt; 
  --outptr; 
  --clkptr; 
  --ordptr; 
  --rpar; 
  --ipar; 
  --funptr; 
  --funtyp; 
  --iwa; 
  --outtb; 
 
  /* Function Body */ 

  /*     ending  subroutine */
  flag=5 ;

  args[0]=&(outtb[7]);
  args[1]=&(outtb[1]);
  C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_1, tvec, &ntvec, &(rpar[1]), &nrd_4, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   

  if(flag < 0 ) return (5-flag);

  args[0]=&(outtb[1]);
  nport = 1;
  Controller_actuator(&flag, &nport, &nevprt, told, (double *)args[0], &nrd_1);

  if(flag < 0 ) return (5-flag);

  args[1]=&(outtb[6]);
  nport = 1;
  Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);

  if(flag < 0 ) return (5-flag);

  args[0]=&(outtb[1]);
  args[1]=&(outtb[1]);
  C2F(bidon)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[1]), &nrd_0, &(ipar[3]), &nrd_1,
     (double *)args[0], &nrd_0, (double *)args[1], &nrd_0);
   

  if(flag < 0 ) return (5-flag);

  args[0]=&(outtb[2]);
  args[1]=&(outtb[7]);
  C2F(dsslti)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[2]),
     &nrd_1, tvec, &ntvec, &(rpar[5]), &nrd_4, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   

  if(flag < 0 ) return (5-flag);

  args[0]=&(outtb[6]);
  args[1]=&(outtb[3]);
  C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[9]), &nrd_1, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   

  if(flag < 0 ) return (5-flag);

  args[0]=&(outtb[8]);
  args[1]=&(outtb[2]);
  C2F(samphold)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[1]), &nrd_0, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   

  if(flag < 0 ) return (5-flag);

  args[0] = &(outtb[3]);
  sz[0] = 1;
  args[1] = &(outtb[4]);
  sz[1] = 1;
  args[2] = &(outtb[8]);
  sz[2] = 1;
  plusblk(&flag, &nevprt, told,&(w[1]), &(x[1]), &nrd_0, &(z[1]),&nrd_0,
     tvec, &ntvec, &(rpar[1]), &nrd_0,&(ipar[1]), &nrd_0, &(args[0]),
     &(sz[0]), &nrd_2,&(args[2]),&(sz[2]),&nrd_1);
   

  if(flag < 0 ) return (5-flag);

  args[0]=&(outtb[5]);
  args[1]=&(outtb[4]);
  C2F(gain)(&flag, &nevprt,told, &(w[1]), &(x[1]), &nrd_0, &(z[1]),
     &nrd_0, tvec, &ntvec, &(rpar[10]), &nrd_1, &(ipar[1]), &nrd_0,
     (double *)args[0], &nrd_1, (double *)args[1], &nrd_1);
   

  if(flag < 0 ) return (5-flag);

  args[1]=&(outtb[5]);
  nport = 2;
  Controller_sensor(&flag, &nport, &nevprt, told, (double *)args[1], &nrd_1);

  if(flag < 0 ) return (5-flag);

  args[0]=&(outtb[8]);
  nport = 2;
  Controller_actuator(&flag, &nport, &nevprt, told, (double *)args[0], &nrd_1);

  if(flag < 0 ) return (5-flag);
  return 0;
} /* ending */

