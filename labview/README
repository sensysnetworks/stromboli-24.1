==============================================================================
                               LabVIEW/LXRT
==============================================================================

This is the LabVIEW(tm) binding for the LXRT realtime application interface in 
user space. 

Disclaimer
==========

LabVIEW(tm) is a trademark of National Instruments. See www.ni.com for
additional information about LabVIEW (manuals, technical resources,
introduction to graphical programming).

License is 'GNU Lesser General Public License'. See file LICENSE for
details.

Binary files *.vi and *.llb are sources of LabVIEW graphical 'G' language
and also GNU LGPL.

The main author is Thomas Leibner <leibner@t-online.de>, with essential help
from the RTAI team at the DIAPM.

Architecture of LabVIEW/LXRT
============================

Currently it is limited to i386 arch only, because:
1. LXRT is only for i386
2. LabVIEW for Linux is only for i386

To use this binding in a meaningful manner, you should feel familiar with
LXRT and LabVIEW. Otherwise this will be of no use for you. Sorry.

LXRT enables hard realtime programming from within userspace. This
LabVIEW/LXRT binding enables you to do the necessary LXRT calls from within
LabVIEW. Basically, you will fire up a separate LabVIEW execution engine for
each realtime task and switch it to realtime mode using LXRT. Non realtime
and realtime LabVIEW tasks will communicate using realtime fifos
(implemented as /dev/rtf*, see fifos subdir of RTAI). Communication,
synchronization and timing between realtime LabVIEW/LXRT tasks will be done
be calling appropiate LXRT functions from within LabVIEW. The
'examples/labviewsound' implements the good old 'sound' example in 100%
LabVIEW, without a single line of 'C'. The overhead of LabVIEW is not
neglectible, it limits execution speed to about 10kHz with my P233MMX.
That's the price you pay for pure graphical programming and debugging of
hard realtime from user space.

Under the hood
==============

The binding consists of a 'CIN' doing the rtai_lxrt() call and some 'CIN'
for functions without lxrt interface.  A 'CIN' is a LabVIEW 'code interface
node' which interfaces graphical programming to self written platform
dependant code. Since a 'CIN' becomes part of a LabVIEW specific program,
called 'VI' (virtual instrument), the self written code it contains is
embedded into the 'VI'.  

To embed your code into a CIN/VI, refer to the 'CIN programming' manual at
www.ni.com. As an overview: you will compile your code using a stub
generated by LabVIEW and a special Makefile generated by the LabVIEW tool
'lvmkf' (see CIN manual for details). Output of the process is a special
*.lsb object format, which becomes embedded into the CIN/VI.

For your easyness the precompiled *.lsb's are included, for the case you
need to reload them into the corresponding or some other VIs. 

LabVIEW implements its own library format *.llb. All VIs implementing the
LabVIEW/LXRT binding are collected into the library 'LVL_LXRT.llb'. The
LVL_LXRT.llb Library file also contains also some wrappers for LXRT
functions. Not all LXRT function calls have been wrapped by LabVIEW code,
instead they serve as examples to do it by yourself (don't forget submitting
e.g. to the author). This is easily done cause all LXRT functions are based
on the same rtai_lxrt() call, which is now possible to do from within
LabVIEW.

Example:

	'BIGFOOBAR.llb' contains 'foobar.vi', 'fOObAR.vi', etc.

	'foobar.vi' include a CIN code interface node loading '_foobar_cin.lsb'

	'_foobar_cin.lsb' is compiled form '_foobar_cin.c' using the Makefile
	generated by 'lvmkf', which is part of the LabVIEW distribution
 


POSIXIO for LabVIEW
===================

To communicate to realtime fifos from non LXRT enabled LabVIEW programs one
uses the standard unix posix-i/o mechanism based on device files. In the
posixio subdir you will find CINs calling the C-lib open, close, read,
write, select, and ioctl functions. These are taken from www.leibner-it.de,
where you find more (e.g a tutorial on how to use them, also without
LabVIEW/LXRT)


Examples
========

In the examples subdir you will find:

--	Some test functions

    These are mainly wrappers to call LXRT related functions with an 
    user interface.

-- 	fifosound

    This VI feeds *.au sound data into a realtime fifo and expects a 
    rt_process to decode and play the date in realtime (8kHz loop). 
    This rt_process is written in C
    
--	rtbeep

    The first example of a realtime task written entirely in graphical 
    LabVIEW "G" code. rtbeep.vi sets some parameters and then executes 
    the rt_process.vi with subroutine priorty, to disable LAbVIEWs own
    cooperative multitasking scheduler. Select "hardrealtime" to 
    enhance the timing of the rt_process
    
--	labviewsound

    This example resembles the sound example of lxrt, but is entirely 
    coded in "G". labviewsound.vi is the feeder for the sound data 
    fifo. It spawns a second labview process to execute the realtime 
    lv_process.vi independant from th feeder. The period of the 
    rt_process.vi is set to 4kHz because 8kHz pushes my P233Mobile 
    beyond the limits.

For running the examples go to the subdir and do a ./ins as root to install 
the lxrt modules. LabVIEW can be run with user privilegies. 

To compile a _foo_cin.c  code resource file use "make _foo_cin.lsb". The Makefile
has been generated by the lvbsutil tool from National Instruments.

==============================================================================
(c) 2002 Thomas Leibner <leibner@t-online.de>
Licensed under GPL Gnu Public License
==============================================================================
