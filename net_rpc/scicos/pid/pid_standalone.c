#include "/home/mante/scilab-2.6/routines/machine.h"
/* Code prototype for standalone use  */
/*     Generated by Code_Generation toolbox of Scicos with scilab-2.6 */
/*     date : 4-Dec-2002 */

#include <stdio.h>
#include <string.h>

#include <sys/types.h>
#include <sys/mman.h>
#include <math.h>

#define KEEP_STATIC_INLINE
#include <rtai_lxrt_user.h>
#include <rtai_lxrt.h>

void pidmain1(double *z, double *t, double * rpar, integer *nrpar,
  integer *ipar,integer *nipar);

void pidmain2(double *z, double *t, double * rpar, integer *nrpar,
  integer *ipar,integer *nipar) ;

void pid_init(double *z, double *t, double * rpar, integer *nrpar,
  integer *ipar,integer *nipar) ;

void pid_end(double *z, double *t, double * rpar, integer *nrpar,
  integer *ipar,integer * nipar) ;

void set_nevprt(int nevprt);

static double RPAR1[ ] = {1,0,-1,1,2,0,1,0,0.01,0,-1,1,1,60,10,10,0,1,
  -1,1,1,1,1,1,-1};
static integer NRPAR1  = 25;
static integer IPAR1[ ]= {1,1,1,2};
static integer NIPAR1  = 4;

static char minid = '0';

/*Main program */
int main(int argc, char *argv[])
{
  RT_TASK *task, *spvtask;
  RTIME now;
  struct { int period, startimer, hardmode, stackinc; } startmode;
  struct { double value; char name[10]; } arg_val;
  struct { int idx; double value; } param;
  int i, len;
  double t0, t;
  double z[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0};

  if (argc == 2 && argv[1][0]) {
     minid = argv[1][0];
  }
  sprintf(arg_val.name, "TASK%c0", minid);
  if (!(task = rt_task_init_schmod(nam2num(arg_val.name), 0, 0, 0, SCHED_FIFO, 0xF))) {
	printf("CANNOT INIT REAL TIME TASK: %s.\n", arg_val.name);
	return 1;
  }
  rt_returnx(rt_receivex(0, &param, 1, &len), &NRPAR1, sizeof(int));
  for (i = 0; i < NRPAR1; i++) {
        sprintf(arg_val.name, "RPAR1:%d", i + 1);
        arg_val.value = RPAR1[i];
        rt_returnx(rt_receivex(0, &param, 1, &len), &arg_val, sizeof(arg_val));
  }
  while (1) {
    if ((spvtask = rt_receivex_if(0, &param, sizeof(param), &len))) {
        rt_returnx(spvtask, &param.idx, sizeof(param.idx));
        if (!param.idx) break;
            RPAR1[param.idx - 1] = param.value;
            printf("changed RPAR1:%d with %g\n", param.idx, param.value);
    }
    usleep(100000);
  }
  rt_returnx(rt_receivex(0, &startmode, sizeof(startmode), &len), &NRPAR1, sizeof(int));
   printf("RECEIVED START MODE:\nPERIOD %d (us), %sSTART THE TIMER, %s REAL TIME, STACK EXPANSION %d BYTES.\n", startmode.period, startmode.startimer ? "" : "DO NOT ", startmode.hardmode ? "HARD" : "SOFT", startmode.stackinc);
  startmode.period *=1000;
  if (startmode.startimer) {
        printf("STARTING TIMER IN ONESHOT MODE.\n");
        rt_set_oneshot_mode();
        start_rt_timer(0);
  }
  pid_init(z,&t,RPAR1,&NRPAR1,IPAR1,&NIPAR1);
  rt_grow_and_lock_stack(startmode.stackinc);
  if (startmode.hardmode) {   
     rt_make_hard_real_time();
  }
  now = rt_get_time();
  t0 = count2nano(now) + startmode.period;
  rt_task_make_periodic(task, now + nano2count(startmode.period), nano2count(startmode.period));
  while (1) {
    t = (rt_get_cpu_time_ns() - t0)*1.0E-9;
    set_nevprt(1);
    pidmain1(z,&t,RPAR1,&NRPAR1,IPAR1,&NIPAR1);
    pidmain2(z,&t,RPAR1,&NRPAR1,IPAR1,&NIPAR1);
    if ((spvtask = rt_receivex_if(0, &param, sizeof(param), &len))) {
        rt_returnx(spvtask, &param.idx, sizeof(param.idx));
        if (!param.idx) break;
            RPAR1[param.idx - 1] = param.value;
            if (!startmode.hardmode) {   
                printf("changed RPAR1:%d with %g\n", param.idx, param.value);
            }
    }
    rt_task_wait_period();
  }
  rt_make_soft_real_time();
  pid_end(z,&t,RPAR1,&NRPAR1,IPAR1,&NIPAR1);
  if (startmode.startimer) {
      stop_rt_timer();
  }
  rt_task_delete(task);
  printf("CONTROLLER EXECUTION ENDED\n");
  return 0;
}
/*----------------------------------------  Lapack messag function */ 
void
C2F(xerbla)(SRNAME,INFO,L)
char *SRNAME;
int *INFO;
long int L;
{
printf("** On entry to %s, parameter number %d had an illegal value\n",SRNAME,*INFO);
}

#include "pid_io.c"
